import {
    type ClingoResult as _ClingoResult,
    runClingo,
} from "clingo-wrapper";

import logicSpecStr from "./logicSpec.lp";
import validationSpecStr from "./validationSpec.lp";

export type ClingoResult = _ClingoResult;

const reConstant = /^[a-z][a-zA-Z0-9]*$/;

function mergeIndexLists(a: number[], b: number[]): number[] {
    const indexSet: Set<number> = new Set<number>(a.concat(b));
    return Array.from(indexSet);
}

/*** ***/

interface GeneratedClingoFacts {
    clingoFacts:      string[];
    invalidConstants: number[];
}

function generateClingoFacts(
    constantTuples:    string[],
    name:              string,
    lineGenFn:         (name: string, constantTuple: string) => string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    console.assert(name.match(reConstant));
    const clingoFacts: string[] = [];
    const invalidPairs: number[] = [];
    for (const [i, part] of constantTuples.entries()) {
        const substrs: string[] = part.split(",").map(s => s.trim());
        
        const isCorrectTupleSize = (substrs.length === expectedTupleSize);
        const allConstantsAreCorrectSyntax = substrs.every(x => x.match(reConstant));

        if (isCorrectTupleSize && allConstantsAreCorrectSyntax) {
            clingoFacts.push(lineGenFn(name, substrs.join(",")));
        } else {
            // Placeholder string added to preserve index correspondence
            clingoFacts.push("");
            invalidPairs.push(i);
        }
    }
    return {
        clingoFacts: clingoFacts,
        invalidConstants: invalidPairs,
    };
}

function generateBaseDef(
    constants:         string[],
    name:              string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    return generateClingoFacts(
        constants,
        name,
        (n, t) => `base(${n},${t}).`,
        expectedTupleSize,
    );
}

function generateInstanceDef(
    constants:         string[],
    name:              string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    return generateClingoFacts(
        constants,
        name,
        (n, t) => `instance(${n}(${t})).`,
        expectedTupleSize,
    );
}

async function getInvalidEdgeFacts(
    requiredFacts: string,
    edgeFacts: string[],
): Promise<number[]> {
    // Use Clingo to get all invalid facts
    const fullQuery = [
        requiredFacts,
        edgeFacts.join("\n"),
        validationSpecStr,
    ].join("\n\n");
    const result = await runClingo(fullQuery);

    if (result.solution === null) {
        throw new Error("runClingo() returned a null solution.");
    }

    // Create a set of invalid facts as strings, with whitespace removed
    const op = (x: string) => (x.replaceAll(/\s/g, "") + ".");
    const invalidEdgeFacts: Set<string> = new Set(result.solution.map(op));
    console.log(invalidEdgeFacts);
    
    // TODO: Refactor to something nicer than a loop.
    const invalidIndices: number[] = [];
    for (const [i, edgeFact] of edgeFacts.entries()) {
        console.log(edgeFact.replaceAll(/\s/g, ""));
        if (invalidEdgeFacts.has(edgeFact.replaceAll(/\s/g, ""))) {
            invalidIndices.push(i);
        }
    }
    return invalidIndices;
}

/*** ***/

export interface SolverParameters {
<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.inputID = k;
            return ht.paramType(x);
        }).join("")
-%>
}

export interface SolverResult {
    // Clingo-specific output.
    // TODO: Make SolverResult backend-agnostic!
    resultObj: null | ClingoResult;
    invalidInputs: {
        // These are lists of integers, where each integer is an index of
        // an invalid string within the corresponding input list.
<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.inputID = k;
            return ht.resultType(x);
        }).join("")
-%>
    };
}

export async function runSolver(params: SolverParameters): Promise<SolverResult> {
    console.log("Running 'runSolver()'.");
<%-
    Object.entries(inputBase).map(([k, v]) => {
        const x = {};
        x.id = k;
        x.tupleSize = v.parameters;
        return ht.runSolverStep1a(x);
    }).join("")
-%>
<%-
    Object.entries(inputConstrained).map(([k, v]) => {
        const x = {};
        x.id = k;
        x.tupleSize = v.parameters;
        return ht.runSolverStep1b(x);
    }).join("")
-%>

    const baseFacts = [
<%-
        Object.entries(inputBase).map(([k, v]) => {
            const x = {};
            x.id = k;
            return ht.runSolverStep2(x);
        }).join("")
-%>
    ].join("\n\n");

    const invalidEdgeFactIndices: number[] = await getInvalidEdgeFacts(
        baseFacts,
        edgeFacts.clingoFacts,
    );

    const totalInvalidEdgeFacts: number[] = mergeIndexLists(
        edgeFacts.invalidConstants,
        invalidEdgeFactIndices,
    );

    const resultObj: null | ClingoResult = await (async()=>{
        const inputsValid = (colourFacts.invalidConstants.length == 0)
                            && (vertexFacts.invalidConstants.length == 0)
                            && (edgeFacts.invalidConstants.length == 0)
                            && (invalidEdgeFactIndices.length === 0);

        if (inputsValid) {
            const fullQuery = [
                baseFacts,
                edgeFacts.clingoFacts.join("\n"),
                logicSpecStr,
            ].join("\n\n");
            return runClingo(fullQuery);
        } else {
            return null;
        }
    })();

    return {
        resultObj: resultObj,
        invalidInputs: {
            colour:  colourFacts.invalidConstants,
            vertex:  vertexFacts.invalidConstants,
            edge:    totalInvalidEdgeFacts,
        },
    };
}

