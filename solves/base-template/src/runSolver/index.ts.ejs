import {
    type ClingoResult as _ClingoResult,
    runClingo,
} from "clingo-wrapper";

import logicSpecStr from "./logicSpec.lp";
import validationSpecStr from "./validationSpec.lp";

export type ClingoResult = _ClingoResult;

const reConstant = /^[a-z][a-zA-Z0-9]*$/;

function mergeIndexLists(a: number[], b: number[]): number[] {
    const indexSet: Set<number> = new Set<number>(a.concat(b));
    return Array.from(indexSet);
}

/*** ***/

interface GeneratedClingoFacts {
    clingoFacts:      string[];
    invalidConstants: number[];
    invalidFacts:     Set<string>;
}

function generateClingoFacts(
    constantTuples:    string[],
    name:              string,
    lineGenFn:         (name: string, constantTuple: string) => string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    console.assert(name.match(reConstant));
    const clingoFacts: string[] = [];
    const invalidPairs: number[] = [];
    const invalidFacts: Set<string> = new Set();
    for (const [i, part] of constantTuples.entries()) {
        const substrs: string[] = part.split(",").map(s => s.trim());
        
        const isCorrectTupleSize = (substrs.length === expectedTupleSize);
        const allConstantsAreCorrectSyntax = substrs.every(x => x.match(reConstant));

        const clingFact = lineGenFn(name, substrs.join(","));
        if (isCorrectTupleSize && allConstantsAreCorrectSyntax) {
            clingoFacts.push(clingFact);
        } else {
            // Placeholder string added to preserve index correspondence
            clingoFacts.push("");
            invalidPairs.push(i);
            invalidFacts.add(clingFact);
        }
    }
    return {
        clingoFacts: clingoFacts,
        invalidConstants: invalidPairs,
        invalidFacts: invalidFacts,
    };
}

function generateBaseDef(
    constants:         string[],
    name:              string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    return generateClingoFacts(
        constants,
        name,
        (n, t) => `base(${n},${t}).`,
        expectedTupleSize,
    );
}

function generateInstanceDef(
    constants:         string[],
    name:              string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    return generateClingoFacts(
        constants,
        name,
        (n, t) => `instance(${n}(${t})).`,
        expectedTupleSize,
    );
}

async function getInvalidEdgeFacts(
    problemInstance: string,
    edgeFacts: string[],
): Promise<number[]> {
    // Use Clingo to get all invalid facts
    const fullQuery = [
        problemInstance,
        validationSpecStr,
    ].join("\n\n");
    const result = await runClingo(fullQuery);

    if (result.solution === null) {
        throw new Error("runClingo() returned a null solution.");
    }

    // Create a set of invalid facts as strings, with whitespace removed
    const op = (x: string) => (x.replaceAll(/\s/g, "") + ".");
    const invalidEdgeFacts: Set<string> = new Set(result.solution.map(op));
    console.log(invalidEdgeFacts);
    
    // TODO: Refactor to something nicer than a loop.
    const invalidIndices: number[] = [];
    for (const [i, edgeFact] of edgeFacts.entries()) {
        console.log(edgeFact.replaceAll(/\s/g, ""));
        if (invalidEdgeFacts.has(edgeFact.replaceAll(/\s/g, ""))) {
            invalidIndices.push(i);
        }
    }
    return invalidIndices;
}

/*** ***/

export interface SolverParameters {
<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.inputID = k;
            return ht.paramType(x);
        }).join("")
-%>
}

export interface SolverResult {
    // Clingo-specific output.
    // TODO: Make SolverResult backend-agnostic!
    resultObj: null | ClingoResult;
    invalidInputs: {
        // These are lists of integers, where each integer is an index of
        // an invalid string within the corresponding input list.
<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.inputID = k;
            return ht.resultType(x);
        }).join("")
-%>
    };
}

export async function runSolver(params: SolverParameters): Promise<SolverResult> {
    console.log("Running 'runSolver()'.");

    const facts: {[K in string]: GeneratedClingoFacts} = {
<%-
        Object.entries(inputBase).map(([k, v]) => {
            const x = {};
            x.id = k;
            x.tupleSize = v.parameters;
            return ht.runSolverStep1a(x);
        }).join("")
-%>
<%-
        Object.entries(inputConstrained).map(([k, v]) => {
            const x = {};
            x.id = k;
            x.tupleSize = v.parameters;
            return ht.runSolverStep1b(x);
        }).join("")
-%>
    };

    const problemInstance: string = Object.values(facts)
        .map(x => x.clingoFacts.join("\n"))
        .join("\n");

    const invalidEdgeFactIndices: number[] = await getInvalidEdgeFacts(
        problemInstance,
        (facts["edge"] as GeneratedClingoFacts).clingoFacts, // TODO: Remove assert
    );

    const totalInvalidEdgeFacts: number[] = mergeIndexLists(
        (facts["edge"] as GeneratedClingoFacts).invalidConstants, // TODO: Remove assert
        invalidEdgeFactIndices,
    );

    const resultObj: null | ClingoResult = await (async()=>{
        const inputsValid = Object.values(facts).every(x => (x.invalidFacts.size === 0))
                            && (invalidEdgeFactIndices.length === 0);

        if (inputsValid) {
            const fullQuery = [
                problemInstance,
                logicSpecStr,
            ].join("\n\n");
            return runClingo(fullQuery);
        } else {
            return null;
        }
    })();

    return {
        resultObj: resultObj,
        invalidInputs: {
            colour:  (facts["colour"] as GeneratedClingoFacts).invalidConstants, // TODO: Remove assert
            vertex:  (facts["vertex"] as GeneratedClingoFacts).invalidConstants, // TODO: Remove assert
            edge:    totalInvalidEdgeFacts,
        },
    };
}

