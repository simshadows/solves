import React from "react";

import {LineHighlighterTextbox} from "./generic/LineHighlighterTextbox";
import {ResultDisplay} from "./ResultDisplay";

import {
    type ParsedSolution,
    runSolver,
} from "../runSolver";

import "./App.css";


function parseInput(s: string): string[] {
    return s.split("\n");
}

interface State {
<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.inputID = k;
            return ht.stateTypeInputValue(x);
        }).join("")
-%>

    solution: ParsedSolution | "not-initialized";
    invalidInputs: Map<AllInputKeys, Set<string>>;
}

export class App extends React.Component<{}, State> {
    constructor(props: {}) {
        super(props);
        this.state = {
            // TODO: This is NOT the source of truth for input values. This input
            //       value state should technically no longer exist, and we should
            //       instead set up refs to read directly from their uncontrolled
            //       textboxes. However, I'm going to be looking into ways to turn
            //       LineHighlighterTextbox into a controllable component.
            //
            //       Either implement a proper uncontrolled
            //       component, or improve LineHighlighterTextbox into a
            //       controllable component!
<%-
            Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
                const x = {};
                x.inputID = k;
                x.initialValues = v.initialValues;
                return ht.stateInputValue(x);
            }).join("")
-%>

            solution: "not-initialized",
            invalidInputs: new Map(),
        };
    }

    async _recalculateOutputs() {
        const result = await runSolver({
<%-
            Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) =>
                "            " +
                `${k}: parseInput(this.state.input${upperCaseFirst(k)}),`
            ).join("\n")
%>
        });
        this.setState({
            solution:      result.solution,
            invalidInputs: result.invalidConstantTuples,
        });
    }

    override async componentDidMount() {
        await this._recalculateOutputs();
    }

    override render() {
        const recalcCallback = async () => this._recalculateOutputs();

<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.stateValue = "input" + upperCaseFirst(k);
            x.onChangeFnName = "set" + upperCaseFirst(k);
            return ht.onChangeHelpers(x);
        }).join("")
-%>

        return <div id="app">
<%-
                Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
                    const x = {};
                    x.inputID = k;
                    x.title = v.title;
                    return ht.jsxParts(x);
                }).join("")
-%>
            <div className="output-table-wrapper">
                <ResultDisplay
                    fieldLabels={["Vertex", "Colour"]}
                    solutionData={
                        (typeof this.state.solution === "string")
                        ? this.state.solution
                        : this.state.solution.color
                    }
                />
            </div>
        </div>;
    }
}

