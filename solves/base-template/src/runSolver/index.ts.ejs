import {
    type ClingoResult as _ClingoResult,
    runClingo,
} from "clingo-wrapper";

import logicSpecStr from "./logicSpec.lp";
import validationSpecStr from "./validationSpec.lp";

export type ClingoResult = _ClingoResult;

type BaseInputKeys = "colour" | "vertex";
type ConstrainedInputKeys = "edge";
//type AllInputKeys = BaseInputKeys | ConstrainedInputKeys;

const reConstant = /^[a-z][a-zA-Z0-9]*$/;

function mergeIndexLists(a: number[], b: number[]): number[] {
    const indexSet: Set<number> = new Set<number>(a.concat(b));
    return Array.from(indexSet);
}

/*** ***/

interface GeneratedClingoFacts {
    clingoFacts:      ReadonlyMap<string, string>; // Map<clingo fact, constant tuple>
    invalidConstants: number[];
    invalidConstantTuples: ReadonlySet<string>;
}

function generateClingoFacts(
    constantTuples:    string[],
    name:              string,
    lineGenFn:         (name: string, constantTuple: string) => string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    console.assert(name.match(reConstant));
    const clingoFacts: Map<string, string> = new Map();
    const invalidPairs: number[] = [];
    const invalidConstantTups: Set<string> = new Set();
    for (const [i, part] of constantTuples.entries()) {
        const substrs: string[] = part.split(",").map(s => s.trim());
        
        const isCorrectTupleSize = (substrs.length === expectedTupleSize);
        const allConstantsAreCorrectSyntax = substrs.every(x => x.match(reConstant));

        if (isCorrectTupleSize && allConstantsAreCorrectSyntax) {
            const fact: string = lineGenFn(name, substrs.join(","));
            console.assert(fact.replaceAll(/\s/g, "") == fact); // Should be no spaces
            clingoFacts.set(fact, part);
        } else {
            invalidPairs.push(i);
            invalidConstantTups.add(part);
        }
    }
    return {
        clingoFacts: clingoFacts,
        invalidConstants: invalidPairs,
        invalidConstantTuples: invalidConstantTups,
    };
}

function generateBaseDef(
    constants:         string[],
    name:              string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    return generateClingoFacts(
        constants,
        name,
        (n, t) => `base(${n},${t}).`,
        expectedTupleSize,
    );
}

function generateInstanceDef(
    constants:         string[],
    name:              string,
    expectedTupleSize: number,
): GeneratedClingoFacts {
    return generateClingoFacts(
        constants,
        name,
        (n, t) => `instance(${n}(${t})).`,
        expectedTupleSize,
    );
}

async function getConstantTuplesThatFailConstraints(
    problemInstance: string,
    constrainedFacts: ReadonlyMap<ConstrainedInputKeys, GeneratedClingoFacts>,
): Promise<Map<ConstrainedInputKeys, Set<string>>> {
    // Use Clingo to get all invalid facts
    const fullQuery = [
        problemInstance,
        validationSpecStr,
    ].join("\n\n");
    const result = await runClingo(fullQuery);

    if (result.solution === null) {
        throw new Error("runClingo() returned a null solution.");
    }

    // Create a set of invalid facts as strings, with whitespace removed
    const op = (x: string) => (x.replaceAll(/\s/g, "") + ".");
    const invalidFacts: Set<string> = new Set(result.solution.map(op));

    // Convert these invalid facts to constant tuples
    const ret: Map<ConstrainedInputKeys, Set<string>> = new Map(
        [...constrainedFacts].map(([inputID, {clingoFacts}]) => [
            inputID,
            new Set(
                [...clingoFacts]
                    .filter(([fact, _]) => invalidFacts.has(fact))
                    .map(([_, tup]) => tup)
            ),
        ])
    );
    return ret;
}

// TODO: Delete this
async function getInvalidEdgeFacts(
    problemInstance: string,
    edgeFacts: string[],
): Promise<number[]> {
    // Use Clingo to get all invalid facts
    const fullQuery = [
        problemInstance,
        validationSpecStr,
    ].join("\n\n");
    const result = await runClingo(fullQuery);

    if (result.solution === null) {
        throw new Error("runClingo() returned a null solution.");
    }

    // Create a set of invalid facts as strings, with whitespace removed
    const op = (x: string) => (x.replaceAll(/\s/g, "") + ".");
    const invalidEdgeFacts: Set<string> = new Set(result.solution.map(op));
    
    // TODO: Refactor to something nicer than a loop.
    const invalidIndices: number[] = [];
    for (const [i, edgeFact] of edgeFacts.entries()) {
        if (invalidEdgeFacts.has(edgeFact.replaceAll(/\s/g, ""))) {
            invalidIndices.push(i);
        }
    }
    return invalidIndices;
}

/*** ***/

export interface SolverParameters {
<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.inputID = k;
            return ht.paramType(x);
        }).join("")
-%>
}

export interface SolverResult {
    // Clingo-specific output.
    // TODO: Make SolverResult backend-agnostic!
    resultObj: null | ClingoResult;
    invalidInputs: {
        // These are lists of integers, where each integer is an index of
        // an invalid string within the corresponding input list.
<%-
        Object.entries({...inputBase, ...inputConstrained}).map(([k, v]) => {
            const x = {};
            x.inputID = k;
            return ht.resultType(x);
        }).join("")
-%>
    };
}

export async function runSolver(params: SolverParameters): Promise<SolverResult> {
    console.log("Running 'runSolver()'.");

    const baseFacts: ReadonlyMap<BaseInputKeys, GeneratedClingoFacts> = new Map([
<%-
        Object.entries(inputBase).map(([k, v]) => "        " +
            `["${k}", generateBaseDef(params.${k}, "${k}", ${v.parameters})],`
        ).join("\n")
%>
    ]);
    const constrainedFacts: ReadonlyMap<ConstrainedInputKeys, GeneratedClingoFacts> = new Map([
<%-
        Object.entries(inputConstrained).map(([k, v]) => "        " +
            `["${k}", generateInstanceDef(params.${k}, "${k}", ${v.parameters})],`
        ).join("\n")
%>
    ]);

    const tmpColourFacts = baseFacts.get("colour");
    const tmpVertexFacts = baseFacts.get("vertex");
    const tmpEdgeFacts = constrainedFacts.get("edge");
    if (tmpColourFacts === undefined) throw "temporary1";
    if (tmpVertexFacts === undefined) throw "temporary2";
    if (tmpEdgeFacts === undefined) throw "temporary3";

    const problemInstance: string = [...baseFacts, ...constrainedFacts]
        .map(([_, v]) => [...v.clingoFacts.keys()].join("\n"))
        .join("\n");

    console.log(await getConstantTuplesThatFailConstraints(
        problemInstance,
        constrainedFacts,
    ));

    const invalidEdgeFactIndices: number[] = await getInvalidEdgeFacts(
        problemInstance,
        [...tmpEdgeFacts.clingoFacts.keys()],
    );

    const totalInvalidEdgeFacts: number[] = mergeIndexLists(
        tmpEdgeFacts.invalidConstants,
        invalidEdgeFactIndices,
    );

    const resultObj: null | ClingoResult = await (async()=>{
        const noInvalidConstantTups = [...baseFacts, ...constrainedFacts]
            .every(([_, v]) => (v.invalidConstantTuples.size === 0));
        const validAgainstConstraints = (invalidEdgeFactIndices.length === 0);

        if (noInvalidConstantTups && validAgainstConstraints) {
            const fullQuery = [
                problemInstance,
                logicSpecStr,
            ].join("\n\n");
            return runClingo(fullQuery);
        } else {
            return null;
        }
    })();

    return {
        resultObj: resultObj,
        invalidInputs: {
            colour:  tmpColourFacts.invalidConstants,
            vertex:  tmpVertexFacts.invalidConstants,
            edge:    totalInvalidEdgeFacts,
        },
    };
}

